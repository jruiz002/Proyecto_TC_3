# Máquina de Turing Reconocedora de Palíndromos
# Reconoce palíndromos sobre el alfabeto {a, b}
# Algoritmo: Compara el primer símbolo con el último, marca ambos, y repite hasta el centro

mt:
  states: [q0, q1, q2, q3, q4, qback, qf, qr]
  input_alphabet: [a, b]
  tape_alphabet: [a, b, X, Y, B]
  initial_state: q0
  accept_states: [qf]
  transitions:
    # Estado q0: Inicio - leer el primer símbolo no marcado
    # Saltar X marcados
    - state: q0
      read: [X]
      write: [X]
      move: R
      next: q0
    
    # Si lee 'a', marcar con 'X' e ir a buscar 'a' al final
    - state: q0
      read: [a]
      write: [X]
      move: R
      next: q1
    
    # Si lee 'b', marcar con 'X' e ir a buscar 'b' al final
    - state: q0
      read: [b]
      write: [X]
      move: R
      next: q2
    
    # Si encuentra blanco, acepta (todo marcado o cadena vacía)
    - state: q0
      read: [B]
      write: [B]
      move: S
      next: qf
    
    # Estado q1: Marcamos 'a' al inicio, buscar último 'a'
    - state: q1
      read: [a]
      write: [a]
      move: R
      next: q1
    
    - state: q1
      read: [b]
      write: [b]
      move: R
      next: q1
    
    - state: q1
      read: [X]
      write: [X]
      move: R
      next: q1
    
    # Llegamos al final, retroceder para marcar último 'a'
    - state: q1
      read: [B]
      write: [B]
      move: L
      next: q3
    
    # Estado q2: Marcamos 'b' al inicio, buscar último 'b'
    - state: q2
      read: [a]
      write: [a]
      move: R
      next: q2
    
    - state: q2
      read: [b]
      write: [b]
      move: R
      next: q2
    
    - state: q2
      read: [X]
      write: [X]
      move: R
      next: q2
    
    # Llegamos al final, retroceder para marcar último 'b'
    - state: q2
      read: [B]
      write: [B]
      move: L
      next: q4
    
    # Estado q3: Buscar y marcar el último 'a'
    # Saltar X's ya marcados
    - state: q3
      read: [X]
      write: [X]
      move: L
      next: q3
    
    # Encontramos 'a', marcar y regresar
    - state: q3
      read: [a]
      write: [X]
      move: L
      next: qback
    
    # Si encuentra B (llegamos al inicio sin encontrar 'a'), aceptar
    - state: q3
      read: [B]
      write: [B]
      move: S
      next: qf
    
    # Si no encuentra 'a', rechazar
    - state: q3
      read: [b]
      write: [b]
      move: S
      next: qr
    
    # Estado q4: Buscar y marcar el último 'b'
    # Saltar X's ya marcados
    - state: q4
      read: [X]
      write: [X]
      move: L
      next: q4
    
    # Encontramos 'b', marcar y regresar
    - state: q4
      read: [b]
      write: [X]
      move: L
      next: qback
    
    # Si encuentra B (llegamos al inicio sin encontrar 'b'), aceptar
    - state: q4
      read: [B]
      write: [B]
      move: S
      next: qf
    
    # Si no encuentra 'b', rechazar
    - state: q4
      read: [a]
      write: [a]
      move: S
      next: qr
    
    # Estado qback: Regresar al inicio
    - state: qback
      read: [a]
      write: [a]
      move: L
      next: qback
    
    - state: qback
      read: [b]
      write: [b]
      move: L
      next: qback
    
    - state: qback
      read: [X]
      write: [X]
      move: L
      next: qback
    
    # Llegamos al inicio (blanco), avanzar y continuar
    - state: qback
      read: [B]
      write: [B]
      move: R
      next: q0